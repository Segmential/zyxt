/* multiline
comment */
// single line comment

// floats, ints, addition and printing
pub x := 4 + 54.3;
ter.out x;

// multiplication & division
x = 2 * 4 / 3.0;
ter.out x;

// concatenation
pub y := (1 ~ 2 ~ 3)@i32;
ter.out "Concatenating numbers", y;

// assignment
y += 234;
ter.out "Adding 234 to y, it is now", y;

// type casting & type retrieval
pub z := 3@str;
ter.out "Var z is", z, "and of type", z@type ;

// booleans and if statements
pub a := false;
ter.out if a {
    ter.out "a is true";
    2;
} else {
    ter.out "a is false";
    1;
};

// scoping & returns
b := 1;
c := 1;
ter.out b, c;
{
    b = 2;
    c := 2;
    ter.out b, c;
    ret;
    ter.out "I will never be printed :(";
};
ter.out b, c;

// variable deletion
to_delete := 4;
to_delete_also := 5;
del to_delete, to_delete_also;

// procs & fns
p := proc {
    ter.out "In a proc, b =", b;
};
p();
q := fn|a| {
    ter.out "This is a function, a =", a;
};
q(3);
q(4);
r := fn|s: str: "default value"| {
    ter.out "Printing string:", s;
};
r("not default value");
r();
s := fn {3};
ter.out s(), s@type;

// calling without parentheses
t := |a, b| ter.out a, b;
t 1, 2;

// function calls on numbers
ter.out 3(4), 6 2;

// string multiplication
ter.out("hi "*5);

// numeric types other than i32 and f64
ter.out(3@u8, 3@u8@type);

// deferred expressions
defer {
    ter.out "This will be printed when the block ends";
};

// preprocessed value
a := pre {
    ter.out "This will be printed before the actual script runs";
    3
};
ter.out a;

// classes (WIP)
/*Point1 := class {
    #init := fn|x: i32, y: i32| {
        #.x = x;
        #.y = y;
    }
};
Point1 2, 3;*/
